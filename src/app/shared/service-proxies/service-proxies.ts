//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IACLAdminUserDTOesServiceProxy {
    /**
     * @return OK
     */
    aCLAdminUserDTOesAll(): Observable<ACLAdminUserDTO[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    aCLAdminUserDTOesPOST(body?: ACLAdminUserDTO | undefined): Observable<ACLAdminUserDTO>;
    /**
     * @return OK
     */
    aCLAdminUserDTOesGET(id: number): Observable<ACLAdminUserDTO>;
    /**
     * @param body (optional) 
     * @return OK
     */
    aCLAdminUserDTOesPUT(id: number, body?: ACLAdminUserDTO | undefined): Observable<void>;
}

@Injectable()
export class ACLAdminUserDTOesServiceProxy implements IACLAdminUserDTOesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "/msps";
    }

    /**
     * @return OK
     */
    aCLAdminUserDTOesAll(): Observable<ACLAdminUserDTO[]> {
        let url_ = this.baseUrl + "/api/ACLAdminUserDTOes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processACLAdminUserDTOesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processACLAdminUserDTOesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ACLAdminUserDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ACLAdminUserDTO[]>;
        }));
    }

    protected processACLAdminUserDTOesAll(response: HttpResponseBase): Observable<ACLAdminUserDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ACLAdminUserDTO.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    aCLAdminUserDTOesPOST(body?: ACLAdminUserDTO | undefined): Observable<ACLAdminUserDTO> {
        let url_ = this.baseUrl + "/api/ACLAdminUserDTOes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processACLAdminUserDTOesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processACLAdminUserDTOesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ACLAdminUserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ACLAdminUserDTO>;
        }));
    }

    protected processACLAdminUserDTOesPOST(response: HttpResponseBase): Observable<ACLAdminUserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ACLAdminUserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    aCLAdminUserDTOesGET(id: number): Observable<ACLAdminUserDTO> {
        let url_ = this.baseUrl + "/api/ACLAdminUserDTOes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processACLAdminUserDTOesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processACLAdminUserDTOesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ACLAdminUserDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ACLAdminUserDTO>;
        }));
    }

    protected processACLAdminUserDTOesGET(response: HttpResponseBase): Observable<ACLAdminUserDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ACLAdminUserDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    aCLAdminUserDTOesPUT(id: number, body?: ACLAdminUserDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ACLAdminUserDTOes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processACLAdminUserDTOesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processACLAdminUserDTOesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processACLAdminUserDTOesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAclTerminalServiceProxy {
    /**
     * @return OK
     */
    getAllAclTerminals(): Observable<AclTerminal[]>;
    /**
     * @return OK
     */
    createAclTerminal(body: AclTerminal): Observable<void>;
    /**
     * @return OK
     */
    getAclTerminalById(autoid: number): Observable<AclTerminal>;
    /**
     * @return OK
     */
    updateAclTerminal(autoid: number, body: AclTerminal): Observable<void>;
}

@Injectable()
export class AclTerminalServiceProxy implements IAclTerminalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "/msps";
    }

    /**
     * @return OK
     */
    getAllAclTerminals(): Observable<AclTerminal[]> {
        let url_ = this.baseUrl + "/api/AclTerminal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAclTerminals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAclTerminals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AclTerminal[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AclTerminal[]>;
        }));
    }

    protected processGetAllAclTerminals(response: HttpResponseBase): Observable<AclTerminal[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AclTerminal.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createAclTerminal(body: AclTerminal): Observable<void> {
        let url_ = this.baseUrl + "/api/AclTerminal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAclTerminal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAclTerminal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateAclTerminal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AclTerminal.fromJS(resultData201);
            return throwException("Created", status, _responseText, _headers, result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAclTerminalById(autoid: number): Observable<AclTerminal> {
        let url_ = this.baseUrl + "/api/AclTerminal/{id}?";
        if (autoid === undefined || autoid === null)
            throw new globalThis.Error("The parameter 'autoid' must be defined and cannot be null.");
        else
            url_ += "autoid=" + encodeURIComponent("" + autoid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAclTerminalById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAclTerminalById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AclTerminal>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AclTerminal>;
        }));
    }

    protected processGetAclTerminalById(response: HttpResponseBase): Observable<AclTerminal> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AclTerminal.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateAclTerminal(autoid: number, body: AclTerminal): Observable<void> {
        let url_ = this.baseUrl + "/api/AclTerminal/{id}?";
        if (autoid === undefined || autoid === null)
            throw new globalThis.Error("The parameter 'autoid' must be defined and cannot be null.");
        else
            url_ += "autoid=" + encodeURIComponent("" + autoid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAclTerminal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAclTerminal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAclTerminal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IACLTerminalDTOesServiceProxy {
    /**
     * @return OK
     */
    aCLTerminalDTOesAll(): Observable<ACLTerminalDTO[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    aCLTerminalDTOesPOST(body?: ACLTerminalDTO | undefined): Observable<ACLTerminalDTO>;
    /**
     * @return OK
     */
    aCLTerminalDTOesGET(id: number): Observable<ACLTerminalDTO>;
    /**
     * @param body (optional) 
     * @return OK
     */
    aCLTerminalDTOesPUT(id: number, body?: ACLTerminalDTO | undefined): Observable<void>;
}

@Injectable()
export class ACLTerminalDTOesServiceProxy implements IACLTerminalDTOesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "/msps";
    }

    /**
     * @return OK
     */
    aCLTerminalDTOesAll(): Observable<ACLTerminalDTO[]> {
        let url_ = this.baseUrl + "/api/ACLTerminalDTOes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processACLTerminalDTOesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processACLTerminalDTOesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ACLTerminalDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ACLTerminalDTO[]>;
        }));
    }

    protected processACLTerminalDTOesAll(response: HttpResponseBase): Observable<ACLTerminalDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ACLTerminalDTO.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    aCLTerminalDTOesPOST(body?: ACLTerminalDTO | undefined): Observable<ACLTerminalDTO> {
        let url_ = this.baseUrl + "/api/ACLTerminalDTOes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processACLTerminalDTOesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processACLTerminalDTOesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ACLTerminalDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ACLTerminalDTO>;
        }));
    }

    protected processACLTerminalDTOesPOST(response: HttpResponseBase): Observable<ACLTerminalDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ACLTerminalDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    aCLTerminalDTOesGET(id: number): Observable<ACLTerminalDTO> {
        let url_ = this.baseUrl + "/api/ACLTerminalDTOes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processACLTerminalDTOesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processACLTerminalDTOesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ACLTerminalDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ACLTerminalDTO>;
        }));
    }

    protected processACLTerminalDTOesGET(response: HttpResponseBase): Observable<ACLTerminalDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ACLTerminalDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    aCLTerminalDTOesPUT(id: number, body?: ACLTerminalDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ACLTerminalDTOes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processACLTerminalDTOesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processACLTerminalDTOesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processACLTerminalDTOesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOpServiceServiceProxy {
    /**
     * @return OK
     */
    getAllOpServices(): Observable<OpService[]>;
    /**
     * @return OK
     */
    createOpService(body: OpService): Observable<void>;
    /**
     * @return OK
     */
    getOpServiceById(autoid: number): Observable<OpService>;
    /**
     * @return OK
     */
    updateOpService(autoid: number, body: OpService): Observable<void>;
}

@Injectable()
export class OpServiceServiceProxy implements IOpServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "/msps";
    }

    /**
     * @return OK
     */
    getAllOpServices(): Observable<OpService[]> {
        let url_ = this.baseUrl + "/api/OpService";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOpServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOpServices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OpService[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OpService[]>;
        }));
    }

    protected processGetAllOpServices(response: HttpResponseBase): Observable<OpService[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OpService.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createOpService(body: OpService): Observable<void> {
        let url_ = this.baseUrl + "/api/OpService";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOpService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOpService(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOpService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OpService.fromJS(resultData201);
            return throwException("Created", status, _responseText, _headers, result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getOpServiceById(autoid: number): Observable<OpService> {
        let url_ = this.baseUrl + "/api/OpService/{id}?";
        if (autoid === undefined || autoid === null)
            throw new globalThis.Error("The parameter 'autoid' must be defined and cannot be null.");
        else
            url_ += "autoid=" + encodeURIComponent("" + autoid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOpServiceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOpServiceById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OpService>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OpService>;
        }));
    }

    protected processGetOpServiceById(response: HttpResponseBase): Observable<OpService> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OpService.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateOpService(autoid: number, body: OpService): Observable<void> {
        let url_ = this.baseUrl + "/api/OpService/{id}?";
        if (autoid === undefined || autoid === null)
            throw new globalThis.Error("The parameter 'autoid' must be defined and cannot be null.");
        else
            url_ += "autoid=" + encodeURIComponent("" + autoid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOpService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOpService(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateOpService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOpSiteServiceProxy {
    /**
     * @return OK
     */
    getAllOpSites(): Observable<OpSite[]>;
    /**
     * @return OK
     */
    createOpSite(body: OpSite): Observable<void>;
    /**
     * @return OK
     */
    getOpSiteById(autoid: number): Observable<OpSite>;
    /**
     * @return OK
     */
    updateOpSite(autoid: number, body: OpSite): Observable<void>;
}

@Injectable()
export class OpSiteServiceProxy implements IOpSiteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "/msps";
    }

    /**
     * @return OK
     */
    getAllOpSites(): Observable<OpSite[]> {
        let url_ = this.baseUrl + "/api/OpSite";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOpSites(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOpSites(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OpSite[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OpSite[]>;
        }));
    }

    protected processGetAllOpSites(response: HttpResponseBase): Observable<OpSite[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OpSite.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createOpSite(body: OpSite): Observable<void> {
        let url_ = this.baseUrl + "/api/OpSite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOpSite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOpSite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOpSite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OpSite.fromJS(resultData201);
            return throwException("Created", status, _responseText, _headers, result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getOpSiteById(autoid: number): Observable<OpSite> {
        let url_ = this.baseUrl + "/api/OpSite/{id}?";
        if (autoid === undefined || autoid === null)
            throw new globalThis.Error("The parameter 'autoid' must be defined and cannot be null.");
        else
            url_ += "autoid=" + encodeURIComponent("" + autoid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOpSiteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOpSiteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OpSite>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OpSite>;
        }));
    }

    protected processGetOpSiteById(response: HttpResponseBase): Observable<OpSite> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OpSite.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateOpSite(autoid: number, body: OpSite): Observable<void> {
        let url_ = this.baseUrl + "/api/OpSite/{id}?";
        if (autoid === undefined || autoid === null)
            throw new globalThis.Error("The parameter 'autoid' must be defined and cannot be null.");
        else
            url_ += "autoid=" + encodeURIComponent("" + autoid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOpSite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOpSite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateOpSite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOPSiteDTOesServiceProxy {
    /**
     * @return OK
     */
    oPSiteDTOesAll(): Observable<OPSiteDTO[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    oPSiteDTOesPOST(body?: OPSiteDTO | undefined): Observable<OPSiteDTO>;
    /**
     * @return OK
     */
    oPSiteDTOesGET(id: number): Observable<OPSiteDTO>;
    /**
     * @param body (optional) 
     * @return OK
     */
    oPSiteDTOesPUT(id: number, body?: OPSiteDTO | undefined): Observable<void>;
}

@Injectable()
export class OPSiteDTOesServiceProxy implements IOPSiteDTOesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "/msps";
    }

    /**
     * @return OK
     */
    oPSiteDTOesAll(): Observable<OPSiteDTO[]> {
        let url_ = this.baseUrl + "/api/OPSiteDTOes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOPSiteDTOesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOPSiteDTOesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OPSiteDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OPSiteDTO[]>;
        }));
    }

    protected processOPSiteDTOesAll(response: HttpResponseBase): Observable<OPSiteDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OPSiteDTO.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    oPSiteDTOesPOST(body?: OPSiteDTO | undefined): Observable<OPSiteDTO> {
        let url_ = this.baseUrl + "/api/OPSiteDTOes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOPSiteDTOesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOPSiteDTOesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OPSiteDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OPSiteDTO>;
        }));
    }

    protected processOPSiteDTOesPOST(response: HttpResponseBase): Observable<OPSiteDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OPSiteDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    oPSiteDTOesGET(id: number): Observable<OPSiteDTO> {
        let url_ = this.baseUrl + "/api/OPSiteDTOes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOPSiteDTOesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOPSiteDTOesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OPSiteDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OPSiteDTO>;
        }));
    }

    protected processOPSiteDTOesGET(response: HttpResponseBase): Observable<OPSiteDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OPSiteDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    oPSiteDTOesPUT(id: number, body?: OPSiteDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/OPSiteDTOes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOPSiteDTOesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOPSiteDTOesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processOPSiteDTOesPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOpVehicleTypeServiceProxy {
    /**
     * @return OK
     */
    getAllOpVehicleTypes(): Observable<OpVehicleType[]>;
    /**
     * @return OK
     */
    createOpVehicleType(body: OpVehicleType): Observable<void>;
    /**
     * @return OK
     */
    getOpVehicleTypeById(autoid: number): Observable<OpVehicleType>;
    /**
     * @return OK
     */
    updateOpVehicleType(autoid: number, body: OpVehicleType): Observable<void>;
}

@Injectable()
export class OpVehicleTypeServiceProxy implements IOpVehicleTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "/msps";
    }

    /**
     * @return OK
     */
    getAllOpVehicleTypes(): Observable<OpVehicleType[]> {
        let url_ = this.baseUrl + "/api/OpVehicleType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOpVehicleTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOpVehicleTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OpVehicleType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OpVehicleType[]>;
        }));
    }

    protected processGetAllOpVehicleTypes(response: HttpResponseBase): Observable<OpVehicleType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OpVehicleType.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createOpVehicleType(body: OpVehicleType): Observable<void> {
        let url_ = this.baseUrl + "/api/OpVehicleType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOpVehicleType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOpVehicleType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOpVehicleType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OpVehicleType.fromJS(resultData201);
            return throwException("Created", status, _responseText, _headers, result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getOpVehicleTypeById(autoid: number): Observable<OpVehicleType> {
        let url_ = this.baseUrl + "/api/OpVehicleType/{id}?";
        if (autoid === undefined || autoid === null)
            throw new globalThis.Error("The parameter 'autoid' must be defined and cannot be null.");
        else
            url_ += "autoid=" + encodeURIComponent("" + autoid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOpVehicleTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOpVehicleTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OpVehicleType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OpVehicleType>;
        }));
    }

    protected processGetOpVehicleTypeById(response: HttpResponseBase): Observable<OpVehicleType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OpVehicleType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    updateOpVehicleType(autoid: number, body: OpVehicleType): Observable<void> {
        let url_ = this.baseUrl + "/api/OpVehicleType/{id}?";
        if (autoid === undefined || autoid === null)
            throw new globalThis.Error("The parameter 'autoid' must be defined and cannot be null.");
        else
            url_ += "autoid=" + encodeURIComponent("" + autoid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOpVehicleType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOpVehicleType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateOpVehicleType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ACLAdminUserDTO implements IACLAdminUserDTO {
    autoid?: number;
    createddate?: Date;
    username?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    opSites?: OPSiteDTO[] | undefined;

    constructor(data?: IACLAdminUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.username = _data["username"];
            this.email = _data["email"];
            this.role = _data["role"];
            if (Array.isArray(_data["opSites"])) {
                this.opSites = [] as any;
                for (let item of _data["opSites"])
                    this.opSites!.push(OPSiteDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ACLAdminUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ACLAdminUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["username"] = this.username;
        data["email"] = this.email;
        data["role"] = this.role;
        if (Array.isArray(this.opSites)) {
            data["opSites"] = [];
            for (let item of this.opSites)
                data["opSites"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IACLAdminUserDTO {
    autoid?: number;
    createddate?: Date;
    username?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    opSites?: OPSiteDTO[] | undefined;
}

export class ACLTerminalDTO implements IACLTerminalDTO {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    macAddress?: string | undefined;
    services?: OPServicesDTO[] | undefined;

    constructor(data?: IACLTerminalDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.macAddress = _data["macAddress"];
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(OPServicesDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ACLTerminalDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ACLTerminalDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["macAddress"] = this.macAddress;
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IACLTerminalDTO {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    macAddress?: string | undefined;
    services?: OPServicesDTO[] | undefined;
}

export class AclAdminUser implements IAclAdminUser {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    usertype?: string | undefined;
    role?: string | undefined;
    profileImage?: string | undefined;
    opSites?: OpSite[] | undefined;
    aclAdminUsersSites?: AclAdminUsersSite[] | undefined;
    opBusinessDayClosedByNavigations?: OpBusinessDay[] | undefined;
    opBusinessDayStartedByNavigations?: OpBusinessDay[] | undefined;
    opParkingLogCheckInUserNavigations?: OpParkingLog[] | undefined;
    opParkingLogCheckOutUserNavigations?: OpParkingLog[] | undefined;

    constructor(data?: IAclAdminUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.usertype = _data["usertype"];
            this.role = _data["role"];
            this.profileImage = _data["profileImage"];
            if (Array.isArray(_data["opSites"])) {
                this.opSites = [] as any;
                for (let item of _data["opSites"]) this.opSites!.push(OpSite.fromJS(item));
            }
            if (Array.isArray(_data["aclAdminUsersSites"])) {
                this.aclAdminUsersSites = [] as any;
                for (let item of _data["aclAdminUsersSites"])
                    this.aclAdminUsersSites!.push(AclAdminUsersSite.fromJS(item));
            }
            if (Array.isArray(_data["opBusinessDayClosedByNavigations"])) {
                this.opBusinessDayClosedByNavigations = [] as any;
                for (let item of _data["opBusinessDayClosedByNavigations"])
                    this.opBusinessDayClosedByNavigations!.push(OpBusinessDay.fromJS(item));
            }
            if (Array.isArray(_data["opBusinessDayStartedByNavigations"])) {
                this.opBusinessDayStartedByNavigations = [] as any;
                for (let item of _data["opBusinessDayStartedByNavigations"])
                    this.opBusinessDayStartedByNavigations!.push(OpBusinessDay.fromJS(item));
            }
            if (Array.isArray(_data["opParkingLogCheckInUserNavigations"])) {
                this.opParkingLogCheckInUserNavigations = [] as any;
                for (let item of _data["opParkingLogCheckInUserNavigations"])
                    this.opParkingLogCheckInUserNavigations!.push(OpParkingLog.fromJS(item));
            }
            if (Array.isArray(_data["opParkingLogCheckOutUserNavigations"])) {
                this.opParkingLogCheckOutUserNavigations = [] as any;
                for (let item of _data["opParkingLogCheckOutUserNavigations"])
                    this.opParkingLogCheckOutUserNavigations!.push(OpParkingLog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AclAdminUser {
        data = typeof data === 'object' ? data : {};
        let result = new AclAdminUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["username"] = this.username;
        data["password"] = this.password;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["usertype"] = this.usertype;
        data["role"] = this.role;
        data["profileImage"] = this.profileImage;
        if (Array.isArray(this.opSites)) {
            data["opSites"] = [];
            for (let item of this.opSites) data["opSites"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.aclAdminUsersSites)) {
            data["aclAdminUsersSites"] = [];
            for (let item of this.aclAdminUsersSites)
                data["aclAdminUsersSites"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opBusinessDayClosedByNavigations)) {
            data["opBusinessDayClosedByNavigations"] = [];
            for (let item of this.opBusinessDayClosedByNavigations)
                data["opBusinessDayClosedByNavigations"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opBusinessDayStartedByNavigations)) {
            data["opBusinessDayStartedByNavigations"] = [];
            for (let item of this.opBusinessDayStartedByNavigations)
                data["opBusinessDayStartedByNavigations"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opParkingLogCheckInUserNavigations)) {
            data["opParkingLogCheckInUserNavigations"] = [];
            for (let item of this.opParkingLogCheckInUserNavigations)
                data["opParkingLogCheckInUserNavigations"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opParkingLogCheckOutUserNavigations)) {
            data["opParkingLogCheckOutUserNavigations"] = [];
            for (let item of this.opParkingLogCheckOutUserNavigations)
                data["opParkingLogCheckOutUserNavigations"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IAclAdminUser {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    usertype?: string | undefined;
    aclAdminUsersSites?: AclAdminUsersSite[] | undefined;
    opBusinessDayClosedByNavigations?: OpBusinessDay[] | undefined;
    opBusinessDayStartedByNavigations?: OpBusinessDay[] | undefined;
    opParkingLogCheckInUserNavigations?: OpParkingLog[] | undefined;
    opParkingLogCheckOutUserNavigations?: OpParkingLog[] | undefined;
}

export class AclAdminUsersSite implements IAclAdminUsersSite {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    adminUserId?: number;
    siteId?: number;
    userType?: string | undefined;
    adminUser?: AclAdminUser;
    site?: OpSite;

    constructor(data?: IAclAdminUsersSite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.adminUserId = _data["adminUserId"];
            this.siteId = _data["siteId"];
            this.userType = _data["userType"];
            this.adminUser = _data["adminUser"] ? AclAdminUser.fromJS(_data["adminUser"]) : undefined as any;
            this.site = _data["site"] ? OpSite.fromJS(_data["site"]) : undefined as any;
        }
    }

    static fromJS(data: any): AclAdminUsersSite {
        data = typeof data === 'object' ? data : {};
        let result = new AclAdminUsersSite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["adminUserId"] = this.adminUserId;
        data["siteId"] = this.siteId;
        data["userType"] = this.userType;
        data["adminUser"] = this.adminUser ? this.adminUser.toJSON() : undefined as any;
        data["site"] = this.site ? this.site.toJSON() : undefined as any;
        return data;
    }
}

export interface IAclAdminUsersSite {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    adminUserId?: number;
    siteId?: number;
    userType?: string | undefined;
    adminUser?: AclAdminUser;
    site?: OpSite;
}

export class AclTerminal implements IAclTerminal {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    pcName?: string | undefined;
    siteId?: number;
    macAddress?: string | undefined;
    cameraIp?: string | undefined;
    cameraPort?: number | undefined;
    cameraUserName?: string | undefined;
    cameraPassword?: string | undefined;
    aclTerminalServices?: AclTerminalService[] | undefined;
    opParkingLogCheckInTerminals?: OpParkingLog[] | undefined;
    opParkingLogCheckOutTerminals?: OpParkingLog[] | undefined;

    constructor(data?: IAclTerminal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.pcName = _data["pcName"];
            this.siteId = _data["siteId"];
            this.macAddress = _data["macAddress"];
            this.cameraIp = _data["cameraIp"];
            this.cameraPort = _data["cameraPort"];
            this.cameraUserName = _data["cameraUserName"];
            this.cameraPassword = _data["cameraPassword"];
            if (Array.isArray(_data["aclTerminalServices"])) {
                this.aclTerminalServices = [] as any;
                for (let item of _data["aclTerminalServices"])
                    this.aclTerminalServices!.push(AclTerminalService.fromJS(item));
            }
            if (Array.isArray(_data["opParkingLogCheckInTerminals"])) {
                this.opParkingLogCheckInTerminals = [] as any;
                for (let item of _data["opParkingLogCheckInTerminals"])
                    this.opParkingLogCheckInTerminals!.push(OpParkingLog.fromJS(item));
            }
            if (Array.isArray(_data["opParkingLogCheckOutTerminals"])) {
                this.opParkingLogCheckOutTerminals = [] as any;
                for (let item of _data["opParkingLogCheckOutTerminals"])
                    this.opParkingLogCheckOutTerminals!.push(OpParkingLog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AclTerminal {
        data = typeof data === 'object' ? data : {};
        let result = new AclTerminal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["pcName"] = this.pcName;
        data["siteId"] = this.siteId;
        data["macAddress"] = this.macAddress;
        data["cameraIp"] = this.cameraIp;
        data["cameraPort"] = this.cameraPort;
        data["cameraUserName"] = this.cameraUserName;
        data["cameraPassword"] = this.cameraPassword;
        if (Array.isArray(this.aclTerminalServices)) {
            data["aclTerminalServices"] = [];
            for (let item of this.aclTerminalServices)
                data["aclTerminalServices"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opParkingLogCheckInTerminals)) {
            data["opParkingLogCheckInTerminals"] = [];
            for (let item of this.opParkingLogCheckInTerminals)
                data["opParkingLogCheckInTerminals"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opParkingLogCheckOutTerminals)) {
            data["opParkingLogCheckOutTerminals"] = [];
            for (let item of this.opParkingLogCheckOutTerminals)
                data["opParkingLogCheckOutTerminals"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IAclTerminal {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    pcName?: string | undefined;
    siteId?: number;
    macAddress?: string | undefined;
    cameraIp?: string | undefined;
    cameraPort?: number | undefined;
    cameraUserName?: string | undefined;
    cameraPassword?: string | undefined;
    aclTerminalServices?: AclTerminalService[] | undefined;
    opParkingLogCheckInTerminals?: OpParkingLog[] | undefined;
    opParkingLogCheckOutTerminals?: OpParkingLog[] | undefined;
}

export class AclTerminalService implements IAclTerminalService {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    terminalId?: number;
    serviceId?: number;
    allowed?: boolean;
    service?: OpService;
    terminal?: AclTerminal;

    constructor(data?: IAclTerminalService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.terminalId = _data["terminalId"];
            this.serviceId = _data["serviceId"];
            this.allowed = _data["allowed"];
            this.service = _data["service"] ? OpService.fromJS(_data["service"]) : undefined as any;
            this.terminal = _data["terminal"] ? AclTerminal.fromJS(_data["terminal"]) : undefined as any;
        }
    }

    static fromJS(data: any): AclTerminalService {
        data = typeof data === 'object' ? data : {};
        let result = new AclTerminalService();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["terminalId"] = this.terminalId;
        data["serviceId"] = this.serviceId;
        data["allowed"] = this.allowed;
        data["service"] = this.service ? this.service.toJSON() : undefined as any;
        data["terminal"] = this.terminal ? this.terminal.toJSON() : undefined as any;
        return data;
    }
}

export interface IAclTerminalService {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    terminalId?: number;
    serviceId?: number;
    allowed?: boolean;
    service?: OpService;
    terminal?: AclTerminal;
}

export class OPServicesDTO implements IOPServicesDTO {
    autoid?: number;
    createddate?: Date;
    serviceName?: string | undefined;
    serviceDescription?: string | undefined;

    constructor(data?: IOPServicesDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.serviceName = _data["serviceName"];
            this.serviceDescription = _data["serviceDescription"];
        }
    }

    static fromJS(data: any): OPServicesDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OPServicesDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["serviceName"] = this.serviceName;
        data["serviceDescription"] = this.serviceDescription;
        return data;
    }
}

export interface IOPServicesDTO {
    autoid?: number;
    createddate?: Date;
    serviceName?: string | undefined;
    serviceDescription?: string | undefined;
}

export class OPSiteDTO implements IOPSiteDTO {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    siteName?: string | undefined;
    siteAddress?: string | undefined;
    siteLongitude?: number | undefined;
    siteLattitude?: number | undefined;
    siteParkingCapacity?: number | undefined;
    city?: string | undefined;
    province?: string | undefined;
    country?: string | undefined;
    siteLogo?: string | undefined;
    services?: OPServicesDTO[] | undefined;

    constructor(data?: IOPSiteDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.siteName = _data["siteName"];
            this.siteAddress = _data["siteAddress"];
            this.siteLongitude = _data["siteLongitude"];
            this.siteLattitude = _data["siteLattitude"];
            this.siteParkingCapacity = _data["siteParkingCapacity"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.country = _data["country"];
            this.siteLogo = _data["siteLogo"];
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(OPServicesDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OPSiteDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OPSiteDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["siteName"] = this.siteName;
        data["siteAddress"] = this.siteAddress;
        data["siteLongitude"] = this.siteLongitude;
        data["siteLattitude"] = this.siteLattitude;
        data["siteParkingCapacity"] = this.siteParkingCapacity;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["siteLogo"] = this.siteLogo;
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOPSiteDTO {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    siteName?: string | undefined;
    siteAddress?: string | undefined;
    siteLongitude?: number | undefined;
    siteLattitude?: number | undefined;
    siteParkingCapacity?: number | undefined;
    city?: string | undefined;
    province?: string | undefined;
    country?: string | undefined;
    siteLogo?: string | undefined;
    services?: OPServicesDTO[] | undefined;
}

export class OpBusinessDay implements IOpBusinessDay {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    siteId?: number;
    businessDate?: Date;
    startedAt?: Date;
    startedBy?: number;
    closedAt?: Date | undefined;
    closedBy?: number | undefined;
    closedByNavigation?: AclAdminUser;
    opParkingLogCheckInBusinessdays?: OpParkingLog[] | undefined;
    opParkingLogCheckOutBusinessdays?: OpParkingLog[] | undefined;
    site?: OpSite;
    startedByNavigation?: AclAdminUser;

    constructor(data?: IOpBusinessDay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.siteId = _data["siteId"];
            this.businessDate = _data["businessDate"] ? new Date(_data["businessDate"].toString()) : undefined as any;
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : undefined as any;
            this.startedBy = _data["startedBy"];
            this.closedAt = _data["closedAt"] ? new Date(_data["closedAt"].toString()) : undefined as any;
            this.closedBy = _data["closedBy"];
            this.closedByNavigation = _data["closedByNavigation"] ? AclAdminUser.fromJS(_data["closedByNavigation"]) : undefined as any;
            if (Array.isArray(_data["opParkingLogCheckInBusinessdays"])) {
                this.opParkingLogCheckInBusinessdays = [] as any;
                for (let item of _data["opParkingLogCheckInBusinessdays"])
                    this.opParkingLogCheckInBusinessdays!.push(OpParkingLog.fromJS(item));
            }
            if (Array.isArray(_data["opParkingLogCheckOutBusinessdays"])) {
                this.opParkingLogCheckOutBusinessdays = [] as any;
                for (let item of _data["opParkingLogCheckOutBusinessdays"])
                    this.opParkingLogCheckOutBusinessdays!.push(OpParkingLog.fromJS(item));
            }
            this.site = _data["site"] ? OpSite.fromJS(_data["site"]) : undefined as any;
            this.startedByNavigation = _data["startedByNavigation"] ? AclAdminUser.fromJS(_data["startedByNavigation"]) : undefined as any;
        }
    }

    static fromJS(data: any): OpBusinessDay {
        data = typeof data === 'object' ? data : {};
        let result = new OpBusinessDay();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["siteId"] = this.siteId;
        data["businessDate"] = this.businessDate ? formatDate(this.businessDate) : undefined as any;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : undefined as any;
        data["startedBy"] = this.startedBy;
        data["closedAt"] = this.closedAt ? this.closedAt.toISOString() : undefined as any;
        data["closedBy"] = this.closedBy;
        data["closedByNavigation"] = this.closedByNavigation ? this.closedByNavigation.toJSON() : undefined as any;
        if (Array.isArray(this.opParkingLogCheckInBusinessdays)) {
            data["opParkingLogCheckInBusinessdays"] = [];
            for (let item of this.opParkingLogCheckInBusinessdays)
                data["opParkingLogCheckInBusinessdays"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opParkingLogCheckOutBusinessdays)) {
            data["opParkingLogCheckOutBusinessdays"] = [];
            for (let item of this.opParkingLogCheckOutBusinessdays)
                data["opParkingLogCheckOutBusinessdays"].push(item ? item.toJSON() : undefined as any);
        }
        data["site"] = this.site ? this.site.toJSON() : undefined as any;
        data["startedByNavigation"] = this.startedByNavigation ? this.startedByNavigation.toJSON() : undefined as any;
        return data;
    }
}

export interface IOpBusinessDay {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    siteId?: number;
    businessDate?: Date;
    startedAt?: Date;
    startedBy?: number;
    closedAt?: Date | undefined;
    closedBy?: number | undefined;
    closedByNavigation?: AclAdminUser;
    opParkingLogCheckInBusinessdays?: OpParkingLog[] | undefined;
    opParkingLogCheckOutBusinessdays?: OpParkingLog[] | undefined;
    site?: OpSite;
    startedByNavigation?: AclAdminUser;
}

export class OpClient implements IOpClient {
    autoid?: number;
    createddate?: string | undefined;
    status?: string | undefined;
    clientName?: string | undefined;
    description?: string | undefined;
    opClientSites?: OpClientSite[] | undefined;

    constructor(data?: IOpClient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"];
            this.status = _data["status"];
            this.clientName = _data["clientName"];
            this.description = _data["description"];
            if (Array.isArray(_data["opClientSites"])) {
                this.opClientSites = [] as any;
                for (let item of _data["opClientSites"])
                    this.opClientSites!.push(OpClientSite.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OpClient {
        data = typeof data === 'object' ? data : {};
        let result = new OpClient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate;
        data["status"] = this.status;
        data["clientName"] = this.clientName;
        data["description"] = this.description;
        if (Array.isArray(this.opClientSites)) {
            data["opClientSites"] = [];
            for (let item of this.opClientSites)
                data["opClientSites"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOpClient {
    autoid?: number;
    createddate?: string | undefined;
    status?: string | undefined;
    clientName?: string | undefined;
    description?: string | undefined;
    opClientSites?: OpClientSite[] | undefined;
}

export class OpClientSite implements IOpClientSite {
    autoid?: number;
    createddate?: string | undefined;
    status?: string | undefined;
    clientId?: number;
    siteId?: number;
    client?: OpClient;
    site?: OpSite;

    constructor(data?: IOpClientSite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"];
            this.status = _data["status"];
            this.clientId = _data["clientId"];
            this.siteId = _data["siteId"];
            this.client = _data["client"] ? OpClient.fromJS(_data["client"]) : undefined as any;
            this.site = _data["site"] ? OpSite.fromJS(_data["site"]) : undefined as any;
        }
    }

    static fromJS(data: any): OpClientSite {
        data = typeof data === 'object' ? data : {};
        let result = new OpClientSite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate;
        data["status"] = this.status;
        data["clientId"] = this.clientId;
        data["siteId"] = this.siteId;
        data["client"] = this.client ? this.client.toJSON() : undefined as any;
        data["site"] = this.site ? this.site.toJSON() : undefined as any;
        return data;
    }
}

export interface IOpClientSite {
    autoid?: number;
    createddate?: string | undefined;
    status?: string | undefined;
    clientId?: number;
    siteId?: number;
    client?: OpClient;
    site?: OpSite;
}

export class OpParkingLog implements IOpParkingLog {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    uniqueAutoId?: string;
    siteId?: number;
    vehicleLpno?: string | undefined;
    serviceIdCheckIn?: number | undefined;
    checkInDateTimeClient?: Date | undefined;
    checkInDateTimeServer?: Date | undefined;
    checkInTerminalId?: number | undefined;
    checkInTerminalPcName?: string | undefined;
    checkInTerminalMac?: string | undefined;
    checkInTechnology?: string | undefined;
    checkInTerminalLocalIp?: string | undefined;
    checkInUser?: number | undefined;
    checkInShiftId?: number;
    checkInBusinessdayId?: number;
    checkInImagePath?: string | undefined;
    rfidQrCode?: string | undefined;
    serviceIdCheckOut?: number | undefined;
    checkOutDateTimeClient?: Date | undefined;
    checkOutDateTimeServer?: Date | undefined;
    checkOutTerminalId?: number | undefined;
    checkOutTerminalPcName?: string | undefined;
    checkOutTerminalMac?: string | undefined;
    checkOutTechnology?: string | undefined;
    checkOutTerminalLocalIp?: string | undefined;
    checkOutUser?: number | undefined;
    checkOutSupervisorUser?: number | undefined;
    checkOutShiftId?: number | undefined;
    checkOutBusinessdayId?: number | undefined;
    checkOutImagePath?: string | undefined;
    basicCharges?: number;
    gstper?: number;
    gstamount?: number;
    netcharges?: number;
    paidCharges?: number;
    regVehicleId?: number | undefined;
    regPersonId?: number | undefined;
    transactionStatus?: string | undefined;
    checkInBusinessday?: OpBusinessDay;
    checkInShift?: OpUserShift;
    checkInTerminal?: AclTerminal;
    checkInUserNavigation?: AclAdminUser;
    checkOutBusinessday?: OpBusinessDay;
    checkOutShift?: OpUserShift;
    checkOutTerminal?: AclTerminal;
    checkOutUserNavigation?: AclAdminUser;
    regPerson?: OpRegisteredPerson;
    regVehicle?: OpRegisteredVehicle;
    serviceIdCheckInNavigation?: OpService;
    serviceIdCheckOutNavigation?: OpService;
    site?: OpSite;

    constructor(data?: IOpParkingLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.uniqueAutoId = _data["uniqueAutoId"];
            this.siteId = _data["siteId"];
            this.vehicleLpno = _data["vehicleLpno"];
            this.serviceIdCheckIn = _data["serviceIdCheckIn"];
            this.checkInDateTimeClient = _data["checkInDateTimeClient"] ? new Date(_data["checkInDateTimeClient"].toString()) : undefined as any;
            this.checkInDateTimeServer = _data["checkInDateTimeServer"] ? new Date(_data["checkInDateTimeServer"].toString()) : undefined as any;
            this.checkInTerminalId = _data["checkInTerminalId"];
            this.checkInTerminalPcName = _data["checkInTerminalPcName"];
            this.checkInTerminalMac = _data["checkInTerminalMac"];
            this.checkInTechnology = _data["checkInTechnology"];
            this.checkInTerminalLocalIp = _data["checkInTerminalLocalIp"];
            this.checkInUser = _data["checkInUser"];
            this.checkInShiftId = _data["checkInShiftId"];
            this.checkInBusinessdayId = _data["checkInBusinessdayId"];
            this.checkInImagePath = _data["checkInImagePath"];
            this.rfidQrCode = _data["rfidQrCode"];
            this.serviceIdCheckOut = _data["serviceIdCheckOut"];
            this.checkOutDateTimeClient = _data["checkOutDateTimeClient"] ? new Date(_data["checkOutDateTimeClient"].toString()) : undefined as any;
            this.checkOutDateTimeServer = _data["checkOutDateTimeServer"] ? new Date(_data["checkOutDateTimeServer"].toString()) : undefined as any;
            this.checkOutTerminalId = _data["checkOutTerminalId"];
            this.checkOutTerminalPcName = _data["checkOutTerminalPcName"];
            this.checkOutTerminalMac = _data["checkOutTerminalMac"];
            this.checkOutTechnology = _data["checkOutTechnology"];
            this.checkOutTerminalLocalIp = _data["checkOutTerminalLocalIp"];
            this.checkOutUser = _data["checkOutUser"];
            this.checkOutSupervisorUser = _data["checkOutSupervisorUser"];
            this.checkOutShiftId = _data["checkOutShiftId"];
            this.checkOutBusinessdayId = _data["checkOutBusinessdayId"];
            this.checkOutImagePath = _data["checkOutImagePath"];
            this.basicCharges = _data["basicCharges"];
            this.gstper = _data["gstper"];
            this.gstamount = _data["gstamount"];
            this.netcharges = _data["netcharges"];
            this.paidCharges = _data["paidCharges"];
            this.regVehicleId = _data["regVehicleId"];
            this.regPersonId = _data["regPersonId"];
            this.transactionStatus = _data["transactionStatus"];
            this.checkInBusinessday = _data["checkInBusinessday"] ? OpBusinessDay.fromJS(_data["checkInBusinessday"]) : undefined as any;
            this.checkInShift = _data["checkInShift"] ? OpUserShift.fromJS(_data["checkInShift"]) : undefined as any;
            this.checkInTerminal = _data["checkInTerminal"] ? AclTerminal.fromJS(_data["checkInTerminal"]) : undefined as any;
            this.checkInUserNavigation = _data["checkInUserNavigation"] ? AclAdminUser.fromJS(_data["checkInUserNavigation"]) : undefined as any;
            this.checkOutBusinessday = _data["checkOutBusinessday"] ? OpBusinessDay.fromJS(_data["checkOutBusinessday"]) : undefined as any;
            this.checkOutShift = _data["checkOutShift"] ? OpUserShift.fromJS(_data["checkOutShift"]) : undefined as any;
            this.checkOutTerminal = _data["checkOutTerminal"] ? AclTerminal.fromJS(_data["checkOutTerminal"]) : undefined as any;
            this.checkOutUserNavigation = _data["checkOutUserNavigation"] ? AclAdminUser.fromJS(_data["checkOutUserNavigation"]) : undefined as any;
            this.regPerson = _data["regPerson"] ? OpRegisteredPerson.fromJS(_data["regPerson"]) : undefined as any;
            this.regVehicle = _data["regVehicle"] ? OpRegisteredVehicle.fromJS(_data["regVehicle"]) : undefined as any;
            this.serviceIdCheckInNavigation = _data["serviceIdCheckInNavigation"] ? OpService.fromJS(_data["serviceIdCheckInNavigation"]) : undefined as any;
            this.serviceIdCheckOutNavigation = _data["serviceIdCheckOutNavigation"] ? OpService.fromJS(_data["serviceIdCheckOutNavigation"]) : undefined as any;
            this.site = _data["site"] ? OpSite.fromJS(_data["site"]) : undefined as any;
        }
    }

    static fromJS(data: any): OpParkingLog {
        data = typeof data === 'object' ? data : {};
        let result = new OpParkingLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["uniqueAutoId"] = this.uniqueAutoId;
        data["siteId"] = this.siteId;
        data["vehicleLpno"] = this.vehicleLpno;
        data["serviceIdCheckIn"] = this.serviceIdCheckIn;
        data["checkInDateTimeClient"] = this.checkInDateTimeClient ? this.checkInDateTimeClient.toISOString() : undefined as any;
        data["checkInDateTimeServer"] = this.checkInDateTimeServer ? this.checkInDateTimeServer.toISOString() : undefined as any;
        data["checkInTerminalId"] = this.checkInTerminalId;
        data["checkInTerminalPcName"] = this.checkInTerminalPcName;
        data["checkInTerminalMac"] = this.checkInTerminalMac;
        data["checkInTechnology"] = this.checkInTechnology;
        data["checkInTerminalLocalIp"] = this.checkInTerminalLocalIp;
        data["checkInUser"] = this.checkInUser;
        data["checkInShiftId"] = this.checkInShiftId;
        data["checkInBusinessdayId"] = this.checkInBusinessdayId;
        data["checkInImagePath"] = this.checkInImagePath;
        data["rfidQrCode"] = this.rfidQrCode;
        data["serviceIdCheckOut"] = this.serviceIdCheckOut;
        data["checkOutDateTimeClient"] = this.checkOutDateTimeClient ? this.checkOutDateTimeClient.toISOString() : undefined as any;
        data["checkOutDateTimeServer"] = this.checkOutDateTimeServer ? this.checkOutDateTimeServer.toISOString() : undefined as any;
        data["checkOutTerminalId"] = this.checkOutTerminalId;
        data["checkOutTerminalPcName"] = this.checkOutTerminalPcName;
        data["checkOutTerminalMac"] = this.checkOutTerminalMac;
        data["checkOutTechnology"] = this.checkOutTechnology;
        data["checkOutTerminalLocalIp"] = this.checkOutTerminalLocalIp;
        data["checkOutUser"] = this.checkOutUser;
        data["checkOutSupervisorUser"] = this.checkOutSupervisorUser;
        data["checkOutShiftId"] = this.checkOutShiftId;
        data["checkOutBusinessdayId"] = this.checkOutBusinessdayId;
        data["checkOutImagePath"] = this.checkOutImagePath;
        data["basicCharges"] = this.basicCharges;
        data["gstper"] = this.gstper;
        data["gstamount"] = this.gstamount;
        data["netcharges"] = this.netcharges;
        data["paidCharges"] = this.paidCharges;
        data["regVehicleId"] = this.regVehicleId;
        data["regPersonId"] = this.regPersonId;
        data["transactionStatus"] = this.transactionStatus;
        data["checkInBusinessday"] = this.checkInBusinessday ? this.checkInBusinessday.toJSON() : undefined as any;
        data["checkInShift"] = this.checkInShift ? this.checkInShift.toJSON() : undefined as any;
        data["checkInTerminal"] = this.checkInTerminal ? this.checkInTerminal.toJSON() : undefined as any;
        data["checkInUserNavigation"] = this.checkInUserNavigation ? this.checkInUserNavigation.toJSON() : undefined as any;
        data["checkOutBusinessday"] = this.checkOutBusinessday ? this.checkOutBusinessday.toJSON() : undefined as any;
        data["checkOutShift"] = this.checkOutShift ? this.checkOutShift.toJSON() : undefined as any;
        data["checkOutTerminal"] = this.checkOutTerminal ? this.checkOutTerminal.toJSON() : undefined as any;
        data["checkOutUserNavigation"] = this.checkOutUserNavigation ? this.checkOutUserNavigation.toJSON() : undefined as any;
        data["regPerson"] = this.regPerson ? this.regPerson.toJSON() : undefined as any;
        data["regVehicle"] = this.regVehicle ? this.regVehicle.toJSON() : undefined as any;
        data["serviceIdCheckInNavigation"] = this.serviceIdCheckInNavigation ? this.serviceIdCheckInNavigation.toJSON() : undefined as any;
        data["serviceIdCheckOutNavigation"] = this.serviceIdCheckOutNavigation ? this.serviceIdCheckOutNavigation.toJSON() : undefined as any;
        data["site"] = this.site ? this.site.toJSON() : undefined as any;
        return data;
    }
}

export interface IOpParkingLog {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    uniqueAutoId?: string;
    siteId?: number;
    vehicleLpno?: string | undefined;
    serviceIdCheckIn?: number | undefined;
    checkInDateTimeClient?: Date | undefined;
    checkInDateTimeServer?: Date | undefined;
    checkInTerminalId?: number | undefined;
    checkInTerminalPcName?: string | undefined;
    checkInTerminalMac?: string | undefined;
    checkInTechnology?: string | undefined;
    checkInTerminalLocalIp?: string | undefined;
    checkInUser?: number | undefined;
    checkInShiftId?: number;
    checkInBusinessdayId?: number;
    checkInImagePath?: string | undefined;
    rfidQrCode?: string | undefined;
    serviceIdCheckOut?: number | undefined;
    checkOutDateTimeClient?: Date | undefined;
    checkOutDateTimeServer?: Date | undefined;
    checkOutTerminalId?: number | undefined;
    checkOutTerminalPcName?: string | undefined;
    checkOutTerminalMac?: string | undefined;
    checkOutTechnology?: string | undefined;
    checkOutTerminalLocalIp?: string | undefined;
    checkOutUser?: number | undefined;
    checkOutSupervisorUser?: number | undefined;
    checkOutShiftId?: number | undefined;
    checkOutBusinessdayId?: number | undefined;
    checkOutImagePath?: string | undefined;
    basicCharges?: number;
    gstper?: number;
    gstamount?: number;
    netcharges?: number;
    paidCharges?: number;
    regVehicleId?: number | undefined;
    regPersonId?: number | undefined;
    transactionStatus?: string | undefined;
    checkInBusinessday?: OpBusinessDay;
    checkInShift?: OpUserShift;
    checkInTerminal?: AclTerminal;
    checkInUserNavigation?: AclAdminUser;
    checkOutBusinessday?: OpBusinessDay;
    checkOutShift?: OpUserShift;
    checkOutTerminal?: AclTerminal;
    checkOutUserNavigation?: AclAdminUser;
    regPerson?: OpRegisteredPerson;
    regVehicle?: OpRegisteredVehicle;
    serviceIdCheckInNavigation?: OpService;
    serviceIdCheckOutNavigation?: OpService;
    site?: OpSite;
}

export class OpPersonSite implements IOpPersonSite {
    autoid?: number;
    createddate?: string | undefined;
    status?: string | undefined;
    personId?: number;
    siteId?: number;
    person?: OpRegisteredPerson;
    site?: OpSite;

    constructor(data?: IOpPersonSite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"];
            this.status = _data["status"];
            this.personId = _data["personId"];
            this.siteId = _data["siteId"];
            this.person = _data["person"] ? OpRegisteredPerson.fromJS(_data["person"]) : undefined as any;
            this.site = _data["site"] ? OpSite.fromJS(_data["site"]) : undefined as any;
        }
    }

    static fromJS(data: any): OpPersonSite {
        data = typeof data === 'object' ? data : {};
        let result = new OpPersonSite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate;
        data["status"] = this.status;
        data["personId"] = this.personId;
        data["siteId"] = this.siteId;
        data["person"] = this.person ? this.person.toJSON() : undefined as any;
        data["site"] = this.site ? this.site.toJSON() : undefined as any;
        return data;
    }
}

export interface IOpPersonSite {
    autoid?: number;
    createddate?: string | undefined;
    status?: string | undefined;
    personId?: number;
    siteId?: number;
    person?: OpRegisteredPerson;
    site?: OpSite;
}

export class OpRegisteredPerson implements IOpRegisteredPerson {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    citizenId?: string | undefined;
    email?: string | undefined;
    contactNo?: string | undefined;
    uniqueCustomCode?: string | undefined;
    secretKey?: string | undefined;
    opParkingLogs?: OpParkingLog[] | undefined;
    opPersonSites?: OpPersonSite[] | undefined;

    constructor(data?: IOpRegisteredPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.citizenId = _data["citizenId"];
            this.email = _data["email"];
            this.contactNo = _data["contactNo"];
            this.uniqueCustomCode = _data["uniqueCustomCode"];
            this.secretKey = _data["secretKey"];
            if (Array.isArray(_data["opParkingLogs"])) {
                this.opParkingLogs = [] as any;
                for (let item of _data["opParkingLogs"])
                    this.opParkingLogs!.push(OpParkingLog.fromJS(item));
            }
            if (Array.isArray(_data["opPersonSites"])) {
                this.opPersonSites = [] as any;
                for (let item of _data["opPersonSites"])
                    this.opPersonSites!.push(OpPersonSite.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OpRegisteredPerson {
        data = typeof data === 'object' ? data : {};
        let result = new OpRegisteredPerson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["citizenId"] = this.citizenId;
        data["email"] = this.email;
        data["contactNo"] = this.contactNo;
        data["uniqueCustomCode"] = this.uniqueCustomCode;
        data["secretKey"] = this.secretKey;
        if (Array.isArray(this.opParkingLogs)) {
            data["opParkingLogs"] = [];
            for (let item of this.opParkingLogs)
                data["opParkingLogs"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opPersonSites)) {
            data["opPersonSites"] = [];
            for (let item of this.opPersonSites)
                data["opPersonSites"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOpRegisteredPerson {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    citizenId?: string | undefined;
    email?: string | undefined;
    contactNo?: string | undefined;
    uniqueCustomCode?: string | undefined;
    secretKey?: string | undefined;
    opParkingLogs?: OpParkingLog[] | undefined;
    opPersonSites?: OpPersonSite[] | undefined;
}

export class OpRegisteredVehicle implements IOpRegisteredVehicle {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    lpno?: string | undefined;
    vehicleType?: number | undefined;
    uniqueIdentityCode?: string | undefined;
    opParkingLogs?: OpParkingLog[] | undefined;
    opVehicleSites?: OpVehicleSite[] | undefined;
    vehicleTypeNavigation?: OpVehicleType;

    constructor(data?: IOpRegisteredVehicle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.lpno = _data["lpno"];
            this.vehicleType = _data["vehicleType"];
            this.uniqueIdentityCode = _data["uniqueIdentityCode"];
            if (Array.isArray(_data["opParkingLogs"])) {
                this.opParkingLogs = [] as any;
                for (let item of _data["opParkingLogs"])
                    this.opParkingLogs!.push(OpParkingLog.fromJS(item));
            }
            if (Array.isArray(_data["opVehicleSites"])) {
                this.opVehicleSites = [] as any;
                for (let item of _data["opVehicleSites"])
                    this.opVehicleSites!.push(OpVehicleSite.fromJS(item));
            }
            this.vehicleTypeNavigation = _data["vehicleTypeNavigation"] ? OpVehicleType.fromJS(_data["vehicleTypeNavigation"]) : undefined as any;
        }
    }

    static fromJS(data: any): OpRegisteredVehicle {
        data = typeof data === 'object' ? data : {};
        let result = new OpRegisteredVehicle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["lpno"] = this.lpno;
        data["vehicleType"] = this.vehicleType;
        data["uniqueIdentityCode"] = this.uniqueIdentityCode;
        if (Array.isArray(this.opParkingLogs)) {
            data["opParkingLogs"] = [];
            for (let item of this.opParkingLogs)
                data["opParkingLogs"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opVehicleSites)) {
            data["opVehicleSites"] = [];
            for (let item of this.opVehicleSites)
                data["opVehicleSites"].push(item ? item.toJSON() : undefined as any);
        }
        data["vehicleTypeNavigation"] = this.vehicleTypeNavigation ? this.vehicleTypeNavigation.toJSON() : undefined as any;
        return data;
    }
}

export interface IOpRegisteredVehicle {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    lpno?: string | undefined;
    vehicleType?: number | undefined;
    uniqueIdentityCode?: string | undefined;
    opParkingLogs?: OpParkingLog[] | undefined;
    opVehicleSites?: OpVehicleSite[] | undefined;
    vehicleTypeNavigation?: OpVehicleType;
}

export class OpService implements IOpService {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    serviceName?: string | undefined;
    description?: string | undefined;
    type?: string | undefined;
    aclTerminalServices?: AclTerminalService[] | undefined;
    opParkingLogServiceIdCheckInNavigations?: OpParkingLog[] | undefined;
    opParkingLogServiceIdCheckOutNavigations?: OpParkingLog[] | undefined;
    opSiteServices?: OpSiteService[] | undefined;

    constructor(data?: IOpService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.serviceName = _data["serviceName"];
            this.description = _data["description"];
            this.type = _data["type"];
            if (Array.isArray(_data["aclTerminalServices"])) {
                this.aclTerminalServices = [] as any;
                for (let item of _data["aclTerminalServices"])
                    this.aclTerminalServices!.push(AclTerminalService.fromJS(item));
            }
            if (Array.isArray(_data["opParkingLogServiceIdCheckInNavigations"])) {
                this.opParkingLogServiceIdCheckInNavigations = [] as any;
                for (let item of _data["opParkingLogServiceIdCheckInNavigations"])
                    this.opParkingLogServiceIdCheckInNavigations!.push(OpParkingLog.fromJS(item));
            }
            if (Array.isArray(_data["opParkingLogServiceIdCheckOutNavigations"])) {
                this.opParkingLogServiceIdCheckOutNavigations = [] as any;
                for (let item of _data["opParkingLogServiceIdCheckOutNavigations"])
                    this.opParkingLogServiceIdCheckOutNavigations!.push(OpParkingLog.fromJS(item));
            }
            if (Array.isArray(_data["opSiteServices"])) {
                this.opSiteServices = [] as any;
                for (let item of _data["opSiteServices"])
                    this.opSiteServices!.push(OpSiteService.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OpService {
        data = typeof data === 'object' ? data : {};
        let result = new OpService();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["serviceName"] = this.serviceName;
        data["description"] = this.description;
        data["type"] = this.type;
        if (Array.isArray(this.aclTerminalServices)) {
            data["aclTerminalServices"] = [];
            for (let item of this.aclTerminalServices)
                data["aclTerminalServices"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opParkingLogServiceIdCheckInNavigations)) {
            data["opParkingLogServiceIdCheckInNavigations"] = [];
            for (let item of this.opParkingLogServiceIdCheckInNavigations)
                data["opParkingLogServiceIdCheckInNavigations"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opParkingLogServiceIdCheckOutNavigations)) {
            data["opParkingLogServiceIdCheckOutNavigations"] = [];
            for (let item of this.opParkingLogServiceIdCheckOutNavigations)
                data["opParkingLogServiceIdCheckOutNavigations"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opSiteServices)) {
            data["opSiteServices"] = [];
            for (let item of this.opSiteServices)
                data["opSiteServices"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOpService {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    serviceName?: string | undefined;
    description?: string | undefined;
    type?: string | undefined;
    aclTerminalServices?: AclTerminalService[] | undefined;
    opParkingLogServiceIdCheckInNavigations?: OpParkingLog[] | undefined;
    opParkingLogServiceIdCheckOutNavigations?: OpParkingLog[] | undefined;
    opSiteServices?: OpSiteService[] | undefined;
}

export class OpSite implements IOpSite {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    siteName?: string | undefined;
    siteAddress?: string | undefined;
    siteLongitude?: number | undefined;
    siteLattitude?: number | undefined;
    siteParkingCapacity?: number | undefined;
    city?: string | undefined;
    province?: string | undefined;
    country?: string | undefined;
    siteLogo?: string | undefined;
    aclAdminUsersSites?: AclAdminUsersSite[] | undefined;
    opBusinessDays?: OpBusinessDay[] | undefined;
    opClientSites?: OpClientSite[] | undefined;
    opParkingLogs?: OpParkingLog[] | undefined;
    opPersonSites?: OpPersonSite[] | undefined;
    opSiteServices?: OpSiteService[] | undefined;
    opVehicleSites?: OpVehicleSite[] | undefined;

    constructor(data?: IOpSite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.siteName = _data["siteName"];
            this.siteAddress = _data["siteAddress"];
            this.siteLongitude = _data["siteLongitude"];
            this.siteLattitude = _data["siteLattitude"];
            this.siteParkingCapacity = _data["siteParkingCapacity"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.country = _data["country"];
            this.siteLogo = _data["siteLogo"];
            if (Array.isArray(_data["aclAdminUsersSites"])) {
                this.aclAdminUsersSites = [] as any;
                for (let item of _data["aclAdminUsersSites"])
                    this.aclAdminUsersSites!.push(AclAdminUsersSite.fromJS(item));
            }
            if (Array.isArray(_data["opBusinessDays"])) {
                this.opBusinessDays = [] as any;
                for (let item of _data["opBusinessDays"])
                    this.opBusinessDays!.push(OpBusinessDay.fromJS(item));
            }
            if (Array.isArray(_data["opClientSites"])) {
                this.opClientSites = [] as any;
                for (let item of _data["opClientSites"])
                    this.opClientSites!.push(OpClientSite.fromJS(item));
            }
            if (Array.isArray(_data["opParkingLogs"])) {
                this.opParkingLogs = [] as any;
                for (let item of _data["opParkingLogs"])
                    this.opParkingLogs!.push(OpParkingLog.fromJS(item));
            }
            if (Array.isArray(_data["opPersonSites"])) {
                this.opPersonSites = [] as any;
                for (let item of _data["opPersonSites"])
                    this.opPersonSites!.push(OpPersonSite.fromJS(item));
            }
            if (Array.isArray(_data["opSiteServices"])) {
                this.opSiteServices = [] as any;
                for (let item of _data["opSiteServices"])
                    this.opSiteServices!.push(OpSiteService.fromJS(item));
            }
            if (Array.isArray(_data["opVehicleSites"])) {
                this.opVehicleSites = [] as any;
                for (let item of _data["opVehicleSites"])
                    this.opVehicleSites!.push(OpVehicleSite.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OpSite {
        data = typeof data === 'object' ? data : {};
        let result = new OpSite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["siteName"] = this.siteName;
        data["siteAddress"] = this.siteAddress;
        data["siteLongitude"] = this.siteLongitude;
        data["siteLattitude"] = this.siteLattitude;
        data["siteParkingCapacity"] = this.siteParkingCapacity;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["siteLogo"] = this.siteLogo;
        if (Array.isArray(this.aclAdminUsersSites)) {
            data["aclAdminUsersSites"] = [];
            for (let item of this.aclAdminUsersSites)
                data["aclAdminUsersSites"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opBusinessDays)) {
            data["opBusinessDays"] = [];
            for (let item of this.opBusinessDays)
                data["opBusinessDays"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opClientSites)) {
            data["opClientSites"] = [];
            for (let item of this.opClientSites)
                data["opClientSites"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opParkingLogs)) {
            data["opParkingLogs"] = [];
            for (let item of this.opParkingLogs)
                data["opParkingLogs"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opPersonSites)) {
            data["opPersonSites"] = [];
            for (let item of this.opPersonSites)
                data["opPersonSites"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opSiteServices)) {
            data["opSiteServices"] = [];
            for (let item of this.opSiteServices)
                data["opSiteServices"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opVehicleSites)) {
            data["opVehicleSites"] = [];
            for (let item of this.opVehicleSites)
                data["opVehicleSites"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOpSite {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    siteName?: string | undefined;
    siteAddress?: string | undefined;
    siteLongitude?: number | undefined;
    siteLattitude?: number | undefined;
    siteParkingCapacity?: number | undefined;
    city?: string | undefined;
    province?: string | undefined;
    country?: string | undefined;
    siteLogo?: string | undefined;
    aclAdminUsersSites?: AclAdminUsersSite[] | undefined;
    opBusinessDays?: OpBusinessDay[] | undefined;
    opClientSites?: OpClientSite[] | undefined;
    opParkingLogs?: OpParkingLog[] | undefined;
    opPersonSites?: OpPersonSite[] | undefined;
    opSiteServices?: OpSiteService[] | undefined;
    opVehicleSites?: OpVehicleSite[] | undefined;
}

export class OpSiteService implements IOpSiteService {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    siteId?: number;
    serviceId?: number;
    basicCharges?: number;
    gstper?: number;
    netCharges?: number;
    dropOffGraceTime?: string | undefined;
    lostFine?: number;
    revisechargesafterEvery?: string | undefined;
    subscriptionDuration?: string | undefined;
    workingTechnologies?: string | undefined;
    gstamount?: number;
    parkingInstruction?: string | undefined;
    service?: OpService;
    site?: OpSite;

    constructor(data?: IOpSiteService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.siteId = _data["siteId"];
            this.serviceId = _data["serviceId"];
            this.basicCharges = _data["basicCharges"];
            this.gstper = _data["gstper"];
            this.netCharges = _data["netCharges"];
            this.dropOffGraceTime = _data["dropOffGraceTime"];
            this.lostFine = _data["lostFine"];
            this.revisechargesafterEvery = _data["revisechargesafterEvery"];
            this.subscriptionDuration = _data["subscriptionDuration"];
            this.workingTechnologies = _data["workingTechnologies"];
            this.gstamount = _data["gstamount"];
            this.parkingInstruction = _data["parkingInstruction"];
            this.service = _data["service"] ? OpService.fromJS(_data["service"]) : undefined as any;
            this.site = _data["site"] ? OpSite.fromJS(_data["site"]) : undefined as any;
        }
    }

    static fromJS(data: any): OpSiteService {
        data = typeof data === 'object' ? data : {};
        let result = new OpSiteService();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["siteId"] = this.siteId;
        data["serviceId"] = this.serviceId;
        data["basicCharges"] = this.basicCharges;
        data["gstper"] = this.gstper;
        data["netCharges"] = this.netCharges;
        data["dropOffGraceTime"] = this.dropOffGraceTime;
        data["lostFine"] = this.lostFine;
        data["revisechargesafterEvery"] = this.revisechargesafterEvery;
        data["subscriptionDuration"] = this.subscriptionDuration;
        data["workingTechnologies"] = this.workingTechnologies;
        data["gstamount"] = this.gstamount;
        data["parkingInstruction"] = this.parkingInstruction;
        data["service"] = this.service ? this.service.toJSON() : undefined as any;
        data["site"] = this.site ? this.site.toJSON() : undefined as any;
        return data;
    }
}

export interface IOpSiteService {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    siteId?: number;
    serviceId?: number;
    basicCharges?: number;
    gstper?: number;
    netCharges?: number;
    dropOffGraceTime?: string | undefined;
    lostFine?: number;
    revisechargesafterEvery?: string | undefined;
    subscriptionDuration?: string | undefined;
    workingTechnologies?: string | undefined;
    gstamount?: number;
    parkingInstruction?: string | undefined;
    service?: OpService;
    site?: OpSite;
}

export class OpUserShift implements IOpUserShift {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    bussinessDateId?: number;
    siteId?: number;
    startedAt?: Date;
    startedBy?: number;
    closedAt?: Date | undefined;
    closedBy?: Date | undefined;
    shiftStartedFor?: number | undefined;
    floatAmount?: number | undefined;
    cardsIssued?: number | undefined;
    cardsCollected?: number | undefined;
    cashCollected?: number | undefined;
    cashShortExcess?: number | undefined;
    cardShortExcess?: number | undefined;
    instrumentNo?: string | undefined;
    shiftType?: string | undefined;
    openingRemarks?: string | undefined;
    closingRemarks?: string | undefined;
    opParkingLogCheckInShifts?: OpParkingLog[] | undefined;
    opParkingLogCheckOutShifts?: OpParkingLog[] | undefined;

    constructor(data?: IOpUserShift) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.bussinessDateId = _data["bussinessDateId"];
            this.siteId = _data["siteId"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : undefined as any;
            this.startedBy = _data["startedBy"];
            this.closedAt = _data["closedAt"] ? new Date(_data["closedAt"].toString()) : undefined as any;
            this.closedBy = _data["closedBy"] ? new Date(_data["closedBy"].toString()) : undefined as any;
            this.shiftStartedFor = _data["shiftStartedFor"];
            this.floatAmount = _data["floatAmount"];
            this.cardsIssued = _data["cardsIssued"];
            this.cardsCollected = _data["cardsCollected"];
            this.cashCollected = _data["cashCollected"];
            this.cashShortExcess = _data["cashShortExcess"];
            this.cardShortExcess = _data["cardShortExcess"];
            this.instrumentNo = _data["instrumentNo"];
            this.shiftType = _data["shiftType"];
            this.openingRemarks = _data["openingRemarks"];
            this.closingRemarks = _data["closingRemarks"];
            if (Array.isArray(_data["opParkingLogCheckInShifts"])) {
                this.opParkingLogCheckInShifts = [] as any;
                for (let item of _data["opParkingLogCheckInShifts"])
                    this.opParkingLogCheckInShifts!.push(OpParkingLog.fromJS(item));
            }
            if (Array.isArray(_data["opParkingLogCheckOutShifts"])) {
                this.opParkingLogCheckOutShifts = [] as any;
                for (let item of _data["opParkingLogCheckOutShifts"])
                    this.opParkingLogCheckOutShifts!.push(OpParkingLog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OpUserShift {
        data = typeof data === 'object' ? data : {};
        let result = new OpUserShift();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["bussinessDateId"] = this.bussinessDateId;
        data["siteId"] = this.siteId;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : undefined as any;
        data["startedBy"] = this.startedBy;
        data["closedAt"] = this.closedAt ? this.closedAt.toISOString() : undefined as any;
        data["closedBy"] = this.closedBy ? this.closedBy.toISOString() : undefined as any;
        data["shiftStartedFor"] = this.shiftStartedFor;
        data["floatAmount"] = this.floatAmount;
        data["cardsIssued"] = this.cardsIssued;
        data["cardsCollected"] = this.cardsCollected;
        data["cashCollected"] = this.cashCollected;
        data["cashShortExcess"] = this.cashShortExcess;
        data["cardShortExcess"] = this.cardShortExcess;
        data["instrumentNo"] = this.instrumentNo;
        data["shiftType"] = this.shiftType;
        data["openingRemarks"] = this.openingRemarks;
        data["closingRemarks"] = this.closingRemarks;
        if (Array.isArray(this.opParkingLogCheckInShifts)) {
            data["opParkingLogCheckInShifts"] = [];
            for (let item of this.opParkingLogCheckInShifts)
                data["opParkingLogCheckInShifts"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.opParkingLogCheckOutShifts)) {
            data["opParkingLogCheckOutShifts"] = [];
            for (let item of this.opParkingLogCheckOutShifts)
                data["opParkingLogCheckOutShifts"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOpUserShift {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    bussinessDateId?: number;
    siteId?: number;
    startedAt?: Date;
    startedBy?: number;
    closedAt?: Date | undefined;
    closedBy?: Date | undefined;
    shiftStartedFor?: number | undefined;
    floatAmount?: number | undefined;
    cardsIssued?: number | undefined;
    cardsCollected?: number | undefined;
    cashCollected?: number | undefined;
    cashShortExcess?: number | undefined;
    cardShortExcess?: number | undefined;
    instrumentNo?: string | undefined;
    shiftType?: string | undefined;
    openingRemarks?: string | undefined;
    closingRemarks?: string | undefined;
    opParkingLogCheckInShifts?: OpParkingLog[] | undefined;
    opParkingLogCheckOutShifts?: OpParkingLog[] | undefined;
}

export class OpVehicleSite implements IOpVehicleSite {
    autoid?: number;
    createddate?: string | undefined;
    status?: string | undefined;
    vehicleId?: number;
    siteId?: number;
    site?: OpSite;
    vehicle?: OpRegisteredVehicle;

    constructor(data?: IOpVehicleSite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"];
            this.status = _data["status"];
            this.vehicleId = _data["vehicleId"];
            this.siteId = _data["siteId"];
            this.site = _data["site"] ? OpSite.fromJS(_data["site"]) : undefined as any;
            this.vehicle = _data["vehicle"] ? OpRegisteredVehicle.fromJS(_data["vehicle"]) : undefined as any;
        }
    }

    static fromJS(data: any): OpVehicleSite {
        data = typeof data === 'object' ? data : {};
        let result = new OpVehicleSite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate;
        data["status"] = this.status;
        data["vehicleId"] = this.vehicleId;
        data["siteId"] = this.siteId;
        data["site"] = this.site ? this.site.toJSON() : undefined as any;
        data["vehicle"] = this.vehicle ? this.vehicle.toJSON() : undefined as any;
        return data;
    }
}

export interface IOpVehicleSite {
    autoid?: number;
    createddate?: string | undefined;
    status?: string | undefined;
    vehicleId?: number;
    siteId?: number;
    site?: OpSite;
    vehicle?: OpRegisteredVehicle;
}

export class OpVehicleType implements IOpVehicleType {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    typeName?: string | undefined;
    description?: string | undefined;
    wheelCount?: number;
    opRegisteredVehicles?: OpRegisteredVehicle[] | undefined;

    constructor(data?: IOpVehicleType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoid = _data["autoid"];
            this.createddate = _data["createddate"] ? new Date(_data["createddate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.typeName = _data["typeName"];
            this.description = _data["description"];
            this.wheelCount = _data["wheelCount"];
            if (Array.isArray(_data["opRegisteredVehicles"])) {
                this.opRegisteredVehicles = [] as any;
                for (let item of _data["opRegisteredVehicles"])
                    this.opRegisteredVehicles!.push(OpRegisteredVehicle.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OpVehicleType {
        data = typeof data === 'object' ? data : {};
        let result = new OpVehicleType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoid"] = this.autoid;
        data["createddate"] = this.createddate ? this.createddate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["typeName"] = this.typeName;
        data["description"] = this.description;
        data["wheelCount"] = this.wheelCount;
        if (Array.isArray(this.opRegisteredVehicles)) {
            data["opRegisteredVehicles"] = [];
            for (let item of this.opRegisteredVehicles)
                data["opRegisteredVehicles"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOpVehicleType {
    autoid?: number;
    createddate?: Date;
    status?: string | undefined;
    typeName?: string | undefined;
    description?: string | undefined;
    wheelCount?: number;
    opRegisteredVehicles?: OpRegisteredVehicle[] | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}